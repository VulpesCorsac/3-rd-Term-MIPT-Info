Ту-ру-ту-туу! Радио "Программинг!", только наш эфир можно компилировать!

Доброе утро, мои маленькие любители программирования. Оклемались после посвята? :3 Плохих новостей не будет - контры я ещё не проверял, поэтому сразу о хорошем. 

Напомню, что сейчас в рубрике "Сделай сам" у нас четыре проекта:
1) Платформер aka Mario
2) Построитель фракталов aka множество Мандельброта
3) Горящий лес, он же сердечная мышца, он же оплодотворённая икринка лягушки, он же - то, о чём ещё завтра будет лекция, смотрите объявы в КПМ'е.
4) Рейтрейсер на коленке

Реалиация любого из этих проектов - не обязательное задание, но я очень старался сделать их интересными и они, определённо, едва ли могут повлиять негативно на Вашу оценку в семестре и опыт. Сроки по факту не ограничены, но напомню, что каждый проект умещается в 250 строк кода обычным стилем.

Теперь о том, как это, собственно, делать. Сначала я постараюсь объяснить вещи, общие для всех проектов а потом перейду к особенностям реализации каждого конкретного. Сразу предупреждаю - будет многабукаф.

Поехали. Так как все проекты основываются на псевдографике, то в них во всех графическая информация на экран будет выводиться символами. Можно выводить совсем просто, вот так:
#define width 20
#define height 10 
for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
    if(blabla(x, y))
      printf("#");
    else
      printf(".");
  }
  printf("\n");
}
Где blabla - некоторая функция от координат символа на экране. Заметим сразу, что циклы идут именно в таком порядке - сначала цикл по строкам(у них разный "y"), потом - по столбцам(у них разный "x"), если перепутать, изображение будет транспонированно. Напомню, что мосле макросов(то бишь #define'ов) нет точки с запятой.

Чуть более продвинутый способ, который необходим, например, в марио - сначала запомнить состояние символьной картинки в массив, а лишь потом его выводить. Как-то так:
char *field = malloc(width * height);
for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
    if(x == 0 || y == 0 || x == width - 1 || y == height - 1)
      field[x + y * width] = '#'; //внимание, '#', а не "#". символ и строка - разные вещи.
    else
      field[x + y * width] = '.';
  }
  printf("\n");
}

for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
      printf("%c", field[x + y * width]);
  }
  printf("\n");
}

Почему я использую запись вида field[x + y * width], а не привычный кому-то со школы field[x][y]. Потому что двумерный массив находится в памяти как попало. Каждая его строка может лежать по совершенному иному адресу, чем две соседние с ней строчки. Казалось бы, ерунда, но мы псевдографику проходим в качестве подготовки к нормальной графике, а в ней изображения всегда хранятся таким образом, что все строки идут в памяти последовательно. Именно поэтому я записываю все строки изображения(каждая строка длиной width, всего строк height) в один массив размером width * height и чтобы обратиться к i-му столбцу и j-й строке я использую запись field[i + j * height]. Такие пироги. Конечно, если найдутся энтузиасты, которым во что бы то ни стало захочется сделать именно двумерный массив, то флаг в руки, летальный исход маловероятен, но я бы советовал освоиться именно с разворачиванием двумерного массива в одномерный.

Далее по каждому проекту отдельно. 

1) Платформер aka Mario
В основе логики этого проекта лежит нехитрая структура данных - тот самый char *field, в котором хранится уровень и символ '.' по координатам i, j означает, что в этой точке - "воздух", а '#' - "стена". Далее нам понадобится также каким-то образом отрисовать главного героя. Я бы рекомендовал завести для этого структуру, которая бы описывала состояние марио. В простейшем случае - это его координаты:
struct Mario
{
  int x, y;
};
struct Mario mario; //mario - переменная, Mario - тип это переменной.
И далее наш цикл отрисовки несколько модифицируется:
for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
      if(x == mario.x && y == mario.y)
        printf("@");
      else
        printf("%c", field[x + y * width]);
  }
  printf("\n");
}
Теперь самое интересная, но и самая сложная часть проекта. До этого момента я рассказывал лишь, как отрисовать статичную картинку. Но ведь марио должен бегать, прыгать и радоваться жизни и вообще динамически менять своё положение! Выход прост. Давайте будем отрисовывать марио и каждый кадр сдвигать его на одну клетку, пока он не приземлится на землю?

while(1) //omg, вечный цикл
{
  if(mario.y + 1 < width && //проверяем, чтобы марио не упал в бездну за пределами массива. Приходько, это условие гарантированно проверится первым.
     field[mario.x + width * (mario.y + 1)] == '.') //если под нами - воздух
     mario.y++; //тогда падаем
  for(y = 0; y < height; y++)
  {
    for(x = 0; x < width; x++)
    {
        if(x == mario.x && y == mario.y)
          printf("@");
        else
          printf("%c", field[x + y * width]);
    }
    printf("\n");
  }
}

Попробовали? Лучше не надо. На экране будет какая угодно мешанина символов кроме того, что хотелось бы увидеть. Причина - картинка будет перерисовываться слишком часто и поэтому ничего не будет видно. Чтобы выйти из положения, достаточно задержать картинку на какое-то время. Мы это сделаем варварским способом и в самом конце бесконечного цикла напишем:
for(w = 0; w < 10000000; w++); //цикл, который ничего не делает, но делает это долго. 

К этому этапу где бы мы ни создали марио(какие бы ни задали изначально x и y), он должен корректно отрисовываться и мы должны видеть, как он падает до самого пола.

Следующий шаг - наверное, самое мутное местро во всех четырёх проектах, поэтому не переживайте, если что-то не поймёте. Мы хотим влиять на героя. Чтобы при нажатии, например, стрелочек он ходил, а при нажатии пробела - прыгал. Для этого придётся реализовать механизм, который называется асинхронным считыванием состояния клавиатуры. Прямо в бесконечном цикле мы каждый раз будем проверять текущие нажатые клавиши и если зажата, например, стрелка "влево", мы будем перемещать марио влево. К сожалению, простого и понятного способа сделать это в линуксе без сторонних библиотек нет. Поэтому я Вам расскажу способ без сторонних библиотек, но не слишком-то простой. Делается это так:
Сначала откроем специальный файл, который находится по адресу "/dev/input/by-path/platform-i8042-serio-0-event-kbd"
int fd = open("/dev/input/by-path/platform-i8042-serio-0-event-kbd", O_RDONLY);
Этот файл - точно такой же особенный файл, как, например, fifo - в нём напрямую ничего не хранится(размер - 0 байт), но через него можно общаться с клавиатурой. По умолчанию доступ к нему закрыт для всех пользователей кроме администратора. Поэтому чтобы открыть доступ, выполните в терминале следующие команды:
cd /dev/input/
sudo chmod a+rwx event0 event1 event2 event3
sudo - означает привелегированная команда, chmod - change mod, a - all(разрешить всем пользователям), rwx - делать всё, event0, event1, event2, event3 - основные устройства ввода-вывода(клавиатура, тачпад, мышь)
Чтобы проверить, что с правами всё ок, fd должен быть неотрицательным.
Далее создадим глобальный массив, в i-м _бите_ которого будет храниться, нажата ли сейчас кнопка с номером i. И объявим глобальную функцию, которая бы считывала состояние этой кнопки из массива:
char keys[1024];
char testKey(int key)
{
    return keys[key / 8] & (1 << (key % 8));
}
Для интересующихся - key / 8 - номер байта, в котором находится бит с номером key. key % 8 - номер бита в этом байте. a & (1 << someBit) проверяет, какой бит находится на месте someBit в байте a. Короче не парьтесь и просто используйте эту функцию.

Далее, мы будем читать текущее состояние клавиатуры каждый кадр(каждую итерацию нашего бесконечного цикла), для этого используем такой системный вызов, объявленный в #include <sys/ioctl.h>:
ioctl (fd, EVIOCGKEY(sizeof keys), &keys);
Не вдаёмся в подробности, как он работает и почему, а просто используем. Итого, чтобы наш марио научился, например, ходить вправо, код будет таким:

#include <sys/ioctl.h>
char keys[1024];
char testKey(int key)
{
    return keys[key / 8] & (1 << (key % 8));
}
int main()
{
    int fd = open("/dev/input/by-path/platform-i8042-serio-0-event-kbd", O_RDONLY);
    memset(keys, 0, sizeof(keys)); //на всякий случай обнулим массив
    //.. создание и инициализация mario и field
    while(1)
    {
        ioctl (fd, EVIOCGKEY(sizeof keys), &keys);

        if(testKey(105) && mario.x - 1 > 0 && field[mario.y * width + mario.x - 1] != '#')
            player.x--;
        //обрабатываем другие кнопки
        //обрабатываем падение
        //отрисовываем
        //ждём
    }
}
В этом коде 105 - код стрелки "влево". Другие кнопок, которые нам понадобятся: 106 - вправо, 103 - вверх. Если понадобятся ещё какие-то кнопки, то можете просто написать мини-программку, которая опрашивает первые, например, 200 кнопок(я не помню, сколько их всего, но меньше) и выводит коды всех зажатых. Далее запускаете программу, нажимаете интересующую кнопку и запоминаете её код, который выводится на экран.

Как реализовывать прыжок. Я просто проверял, что если зажата кнопка вверх, сейчас под героем земля(в клеточке под ним - символ '#'), то присваивал некоторой переменной mario.jumpTime = 10. Далее в цикле каждый раз смотрел, что если значение этой переменной больше 0, то эту итерацию гравитация на марио действует не вниз(падает), а вверх(прыгает) и уменьшал значение этой переменной на 1.

В качестве дополнительных фишек можно реализовать, например, лаву, врагов, переход между уровнями, секреты и переключатели - всё в Ваших руках и делается примерно по аналогии. 

2) Построитель фракталов
Наверное, самый простой с точки зрения программирования проект, поэтому рекомендую его тем, кто хочет себя попробовать, но не уверен в своих силах и сейчас постараюсь объяснить, как его написать.
Для начала чуть матана. Пусть с - некоторое комплексное число вида c = x + i * y; Считается, что с принадлежит множеству Мандельброта, если последовательность вида Z(n + 1) = Zn * Zn + c - ограничена, при этом Z0 = 0. Мы не можем точно сказать, ограничена последовательность или нет, но мы можем проверить первые её N членов и если они все по модулю меньше некоторого числа A, то мы можем предположить, что и все остальные члены этой последовательно, быть может, также меньше этого A. Если N и A устремить к бесконечности, то последовательность действительно будет сходящейся по определению, но я бы советовал для тестов N = 20, A = 100, этого вполне хватит. Нам понадобятся две операции с комплексными числами - сложение и умножение. Давайте введём структуру, описывающую комплексное число и операции с ним:
struct Complex
{
  float re, im; //обратим внимание, float
};
struct Complex add(struct Complex a, struct Complex b)
{
  Complex res;
  res.re = a.re + b.re;
  res.im = a.im + b.im;
  return res;
}
struct Complex mul(struct Complex a, struct Complex b)
{
  //..
}
Далее определим функцию, которая нашим эвристическим методом будет определять, принадлежит точка c множеству или нет:
int Mandelbrot(struct Complex c)
{
  Complex z; z.re = 0; z.im = 0;
  for(i = 0; i < 20; i++)
  {
    z = add(mul(z, z), c);
    if(z.re * z.re + z.im * z.im > 100 * 100) return i + 1;
  }
  return 0;
}
Обратите внимание, что моя функция выводит 0, если мы решили, что последовательность ограничена, и некоторое положительное число i + 1, которое означает, насколько быстро она расходится. Потом пригодится.

Следующим шагом мы хотим определить, принадлежит ли каждая точка на нашем экране множеству Мандельброта. В первом приближении это можно было бы сделать так:

for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
    struct Complex c;
    c.re = x;
    c.im = y;

    if(Mandelbrot(c) > 0)
      printf("#");
    else
      printf(".");
  }
  printf("\n");
}

Этот код работает и всё такое, но проблема в том, что самое интересное у множества Мандельброта происходит в диапазоне [-1..1][-1..1], а не в нашем [0..width-1][0..height-1]
Поэтому давайте переведём наши x и у в диапазон [-1..1]. Сделаем это так:
float minx = -1.0f; float maxx = 1.0f;
float miny = -1.0f; float maxy = 1.0f;
//...
c.re = minx + (float)x / (float)width  * (maxx - minx);
c.im = miny + (float)y / (float)height * (maxy - miny);

При этом мы можем задавать такие minx/maxx/miny/maxy, какие нам угодно и тем самым рассматривать крупнее тот участок фрактала, который нам интересен. Например, я отрисовку также заталкивал в бесконечный цикл и, считывая, какие символы вводятся с клавиатуры, сдвигал и расширял/сжимал рамку соответствующим образом. Например, если ввели символ "a", я хочу, чтобы вся рамка сдвинулась влево. Поэтому делаю так:
float d = (maxx - minx) * 0.1;
minx -= d;
maxx -= d;
Если я хочу расширить рамку(уменьшить изображение), то делаю так:
float dx = (maxx - minx) * 0.1;
float dy = (maxy - miny) * 0.1;
minx -= dx;
maxx += dx;
miny -= dy;
maxy += dy;

Следующий шаг - помните, что наша функция Mandelbrot возвращает на самом деле число? Его можно характеризовать как удалённость точки от множества Мандельброта. Ну, косвенно. И каждому значению удалённости можно выводить свой символ. Примерно так:
char *palette = "fakdsfja;lkdfjadkfajsdfkasjdkfhalkdfjhaklsdjfa";
printf("%c", palette[Mandlebrot(c)]);
только символы в "палитру" лучше заталкивать поосмысленнее, чтобы они шли примерно по уменьшению или увеличению яркости. Тут лучше поэкспериментировать, но я расскажу подробней о том, как это делать, в проекте про рейтрейсер. Кажется, всё? Можно бросаться писать!

3) Горящий лес/сокращение сердца/депрессивные нейроны в мозге/оболочка оплодотворяемой яйцеклетки/ещё мильон процессов, которых подчиняются такому характеру
Проект тоже относительно прост в логике, но несколько объёмнее, чем предыдущий, при реализации. Хотя в нём нет таких закидонов со сложными штуками вроде асинхронного ввода и отрисовки, как в Марио. Приступим.

Давайте для ясности будем рассматривать процесс и, соответственно, писать программу, на примере горения леса. Напомню, в чём заключается модель:
Каждая клетка - дерево. Дерево может либо просто стоять, либо гореть, либо быть сгоревшим. Дерево переходит из состояния "просто стоит" в состояние "загорелось", если рядом на протяжении некоторого времени находятся горящие деревья. Горящее дерево переходит в состояние "сгорело", спустя некоторое время burnTime. Сгоревшее дерево вновь отрастает спустя время recuperationTime. burnTime и recuperationTime - некоторые константы, которые мы сами задаём руками, какие в голову взбредёт. Я потом расскажу, с какими значениями можно получать что-то более-менее интересное.
Итак, давайте начнём с того, что опишем структуру одного дерева.
struct Tree
{
  int state;
  int timeElapsed;
};
У дерева есть два свойства:
state - переменная, которая обозначает текущее состояние дерева и принимает значения 0(нормальное), 1(горит) и 2(сгорело).
timeElapsed - переменная, которая обозначает, сколько времени дереву осталось провести в текущем состоянии. Например, если state = 1 и timeElapsed = 10, это значит, что сейчас дерево горит и будет гореть ещё 10 ходов, потом потухнет :( Аналогично если state = 2 и timeElapsed = 4 означает, что дерево сгорело, но через 4 хода снова отрастёт. А вот состояние state = 0 и timeElapsed = чему-то - несколько особенное. Его смысл я объясню позже. Оно отличается от предыдущих двух примеров тем, что если дерево не горит и вокруг него тоже ничего не горит, то оно может пребывать в этом состоянии сколько угодно.

Далее определим структуру поля:
struct Tree field[width * height];
Очень похоже на марио, только отрисовывать будем каждое дерево в зависимости от его состояния:
for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
      if(field[x + y * width].state == 0)
        printf("#"); //типа дерево
      if(field[x + y * width].state == 1)
        printf("*"); //типа огонь
      if(field[x + y * width].state == 2)
        printf("."); //типа сгоревший пень
  }
  printf("\n");
}
Мы отрисовали некоторое текущее состояние нашего поля. А теперь - самое интересное. Собственно, зачем мы тут собрались. Нам надо научиться переводить поле из момента времени t в момент времени t + 1. И вот как мы это будем делать. Мы заведём ещё один массив, в который будем записывать следующее состояние поля и модифицировать его:

struct Tree nextField[width * height];

for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
    nextField[x + y * width] = field[x + y * width];
    if(nextField[x + y * width].state == 1) //дерево горит
    {
      nextField[x + y * width].timeElapsed--;
      if(nextField[x + y * width].timeElapsed < 0) //догорело?
      {
        nextField[x + y * width].state = 2; //догорело.
        nextField[x + y * width].timeElapsed = recuperationTime;
      }
    }
  }
}

Штука, которую я описал выше, называется конечным автоматом - у каждого дерева есть несколько состояний, между которыми оно при определённых условиях переходит. Я написал один из двух простых случаев - когда дерево переходит из состояния "горит" в состояние "сгорело". Но есть ещё два перехода: "сгорело"->"отросло" и "отросло"->"горит". Первый переход, уверен, мои юные слушатели в состоянии реализовать полностью по аналогии. Второй же переход несколько хитрее, так как дерево может загореться, если один или несколько его соседей горят некоторое время. Так вот пусть переменная timeElapsed будет уменьшаться у нормального дерева на 1 каждый раз, когда на протяжении единицы времени рядом с ним горит соседнее дерево. То есть если рядом с деревом горят три непосредственных соседа, то за единицу времени его timeElapsed уменьшится сразу на 3 и когда он станет отрицательным, оно тоже загорится. Давайте облагородим эту мешанину из слов псевдокодом:

for(y = 0; y < height; y++)
{
  for(x = 0; x < width; x++)
  {
    //проверяем переход горит -> сгорело
    //сгорело->отросло
    if(newField[x + y * width].state == 0)
    {
      for(i = 0; i < 8; i++) //у каждого дерева - 8 соседей
      {
        int nx = ???;
        int ny = ???; //координаты соседа с номером i. сами подумайте, как описать
        if(nx >= 0 && nx < width && ny >= 0 && ny < height)
        {
          if(field[nx + width * ny].state == 1) //вот тут нам и понадобился field вместо newField
            newField[x + y * width].timeElapsed--;
        }
      }
      if(newField[x + y * width].timeElapsed < 0)
      {
        newField[x + y * width].state = 1;
        newField[x + y * width].timeElapsed = burnTime;
      }
    }
  }
}

Внимательный слушатель, должно быть, уже заметил небольшой подвох: при переходе из состояния "сгорело" в состояние "нормально" нам понадобится чему-то присвоить timeElapsed. Это будет третья управляющая константа, которая характеризует, насколько тяжело дереву загореться. Назовём её lightTime. Например, если lightTime = 6, это означает, что чтобы дерево загорелось, рядом с ним должен либо 6 ходов гореть один сосед, либо два хода три соседа, либо 3 соседа 2 хода либо вы сами можете разложить число 6 на множители. Так вот. Я в своих нечеловеческих тестах использовал:
#define burnTime 8
#define recuperationTime 8
#define lightTime 8

Чтобы начать что-то созерцать, нужно задать некоторое начальное условие. Я бы советовал для начала просто сказать, что пусть N деревьев со случайными координатами изначально горят, остальные - в нормальном состоянии и посмотреть, что будет. Потом, если почему-то ничего не падает и подаёт признаки жизни, задать две полосы, одна сразу под другой - одна полоса горящих деревьев и ещё одна - только что сгоревших и попробовать получить спиральные волны, которые я показывал на семинаре. Дерзайте.

4) Рейтрейсер на коленке. 
Сразу предупреждаю - проект только для уверенных в себе энтузиастов. Неуверенным в себе безынициавным ребятам лучше взять один из предыдущих, потому что придётся освоить сразу несколько новых понятий, зато если удастся, то получите кучу экспы и сможете при приёме на работу на вопрос "опыт программирования?" ответить "пф, на втором курсе рейтрейсер писал". После такого вас сразу возьмут, например, лифтёром.

Итак. Нам понадобятся:
Камера - 1шт
Сферы - произвольное количество шт
Источник света - 1шт

Как вы помните, я из сфер составил, разумеется, метан. Потому что это - первое, что приходит в голову. Вы же можете пойти другой дорогой и, подключив фантазию, составить из сфер микки-мауса, матрёшку или какое-нибудь непотребство. 

Как работает рейтрейсер. Сначала нам нужно влюбиться. Глубоко и всем серцем. В вектора. Векторной математики будет много - она не слишком сложная, но к ней надо привыкнуть и программирование векторной математики - вообще отдельное умение, которым можно овладеть лишь с практикой. Начнём. Заведём структуру вектора:
struct vec3
{
  float x, y, z;
};
Такой структурой можно обозначить и точку в пространстве, и направление, и нормаль к плоскости, и вектор развития страны(только тогда вектор будет мнимым). Ладно, последняя шутка была ужасной. Теперь научимся определять операции над вектором. Для примера я рассмотрю сложение:
struct vec3 add(struct vec3 a, struct vec3 b)
{
  vec3 res;
  res.x = a.x + b.x;
  res.y = a.y + b.y;
  res.z = a.z + b.z;
  return res;
}
Кто до сюда дочитал от самого раздела с множеством Мандельброта, быть может, заметил некоторую аналогию с комплексными числами. Также нам понадобятся ещё несколько операций:
struct vec3 mul(struct vec3 a, float val) //умножение вектора на число
float length(struct vec3 a) //длина вектора
float dot(struct vec3 a, struct vec3 b) //скалярное произведение

Думаю, дорогой читатель в состоянии реализовать их по аналогии, на худой конец вооружившись учебником аналита.

Теперь давайте опишем сущности, которые нам понадобятся. Для начала заведём массив сфер:
#define maxSpheresCount = 1000;
struct Sphere
{
  struct vec3 pos;
  float radius;
} spheres[maxSpheresCount];
int spheresCount = 0;
Обратите внимание, что в maxSpheresCount я решил сохранить максимальное количество сфер, под которые мы выделили память, в то время как в spheresCount хранится, сколько из них мы реально используем. Желающие могут, конечно, не выделываться и использовать динамическую аллокацию памяти.

Также важно почему я пишу struct vec3 pos, а не
struct Sphere
{
  float x, y, z;
  float radius;
}
потому что если работать с вектором, как с целым и, например, складывать векторы a и b как c = add(a, b), вместо
c.x = a.x + b.x;
c.y = a.y + b.y;
c.z = a.z + b.z;
то код не только становится короче, его ещё гораздо легче читать, модифицировать и в нём сложнее допустить ошибку. Короче поверьте на слово - со структурой вектора реально удобнее работать, чем просто с тремя координатами, подход называется объектостью и я вам про него ещё весь следующий семестр буду мозги промывать.

Теперь чуть сложнее и менее очевидно. Нужно описать наблюдателя или камеру, что то же самое. В трёхмерной графике камеру принято описывать тремя векторами: положение центра, направление "вперёд", "вправо" и "вверх". Как-то так:
struct Camera
{
  vec3 pos;
  struct vec3 forth, right, up;
};
Обратите внимание, что здесь pos - это координаты точки в глобальной системы координат, а forth, right и up - направления. Короче если мы хотим, чтобы наблюдатель смотрел из точки (1, 2, 3) вдоль направлении оси z, то его можно описать так:
camera.pos  .x = 1; camera.pos  .y  = 2; camera.pos  .z = 3;
camera.forth.x = 0; camera.forth.y  = 0; camera.forth.z = 1; //forth - вектор, куда наблюдатель смотрит. вдоль оси z
camera.right.x = 1; camera.right.y  = 0; camera.right.z = 0; //пусть направление "вправо" совпадает с осью x
camera.up   .x = 0; camera.up   .y  = 1; camera.up   .z = 0; //направление "вверх" - с осью y

Далее в чём, собственно, суть метода , который называется "трассировка лучей". В самом простом случае мы выпускаем все лучи, которые попадают в объектив воображаемой камеры(или в глаз наблюдателя, как угодно) и определяем, в какой трёхмерный объект попадёт этот луч. Далее мы знаем, какой точке на экране нашего монитора соответствует каждый такой луч и присваиваем ей цвет того объекта, в который он попал. Смотрите, я даже иллюстрацию нагуглил:
http://upload.wikimedia.org/wikipedia/commons/8/83/Ray_trace_diagram.svg

Чтобы понять, какие именно лучи мы будем выпускать, мы будем выпускать ровно по одному лучу для каждой точки на экране(одна точка - один символ или, в случае с обычной непсевдографикой - один пиксел). Следующий момент является одним из самых нетривиальных, но в то же врем ключевых в трёхмерной графике - как определить, какой экранной точке соответствует какой луч. Пусть у нас экран разрешением width x height точек. Представим его как экран, который стоит перед проектором, на расстоянии d. Пусть реальная ширина экрана - X, а высота - Y. На предыдущей картинке проектор - это аналог камеры, а экран - аналог вон того клеточного треугольника.
Очевидно, что все лучи пройдут через центр камеры. Но чтобы описать луч, нам нужно знать любые его две точки. Давайте теперь найдём точку, в которой луч пересечёт экран в пикселе с координатами i, j. Если расписать эту штуку векторно, то получится что-то вроде:
camera.pos + 
  camera.forth  * d + 
  camera.right  * ((float)i / width  - 0.5) * X + 
  camera.up     * ((float)j / height - 0.5) * Y +   
Обратите внимание, что pos, forth, right и up - вектора, всё остальное - скаляры. Эту формулу напрямую можно реализоват при помощи всего двух операций: mul и add.

Всё. Самое сложное позади. Теперь мы можем пробежаться по всем пикселам на экране(по всем координатам i, j) и для каждой из них выпустить луч, который мы можем задать двумя точками. Если луч пересекает одну из сфер, то ставим, например, "#", иначе - " "(пробел). Да, нам понадобится написать функцию, которая определяет, пересекает ли луч сферу, но я верю, что Вы не настолько забыли аналит, чтобы мне пришлось рассказывать, как это сделать.

В такой реализации величины d(расстояние до экрана), X(ширина экрана) и Y(высота) - константы, которые нужно указать явно. Выбирать их нужно из следующих соображений:
X / d - тангенс угла горизонтального обзора. Обычно в компьютерных играх выбирают примерно X / d = 1, что соответствует углу обзора в 90 градусов
X / Y - отношение ширины экрана к высоте. Чтобы изображение получалось неискажённым, следует выбирать таким же, как и отношение ширины к высоте вашей консоли. Ничего страшного, если немного ошибиться - изображение просто получится сплюснутым или вытянутым -легко подогнать.

Если просто запрограммировать то, что я описал выше, то результатом будут неказистые круглые области на экране, состоящие из символов решёток. Чтобы разнообразить происходящее, есть два пути: добавить управление камерой с клавиатуры/мыши и добавить освещение. Чтобы реализовать первое, обратитесь за помощью к марио - я там как раз рассказывал, как считывать состояние клавиатуры. Аналогично тому, как там на разные кнопки мы перемещали героя, здесь нужно перемещать и вращать камеру. Второй путь - освещение. Я предлагаю реализовать одну из самых простых моделей освещения - фонга http://en.wikipedia.org/wiki/Phong_reflection_model

В самом простом случае освещение каждой точки каждого объекта складывается из двух величин - ambient(окружающее освещение) и diffuse(диффузный цвет). Определим цвет как одно число 0..1, которое обозначает яркость точки. Пусть 0 - чёрный цвет. Такого цвета самые неосвещённые участки и все лучи, которые не попали ни в один объект. 1 - самый яркий участок самого освещённого тела. Так вот, по модели фонга цвет тела определяется таким образом:
color = ambient + diffuse * max(-dot(lightDir, normal), 0), где ambient - константа, обычно 0.1, diffuse - тоже константа, обычно 0.9, lightDir - вектор падения света, normal - внешняя нормаль к поверхности объекта, в точке пересечения с лучом. Для сферы найти нормаль легко - (sub(p, sphere.pos)) / length(sub(p, sphere.pos)). Смысл этой магической формулы в следующем - все самые тёмные точки имеют цвет ambient. Если свет падает перпендикулярно к поверхности объекта (dot(lightDir, normal) == -1), то освещение максимально, точка ярка. Если свет падает по касательной (dot(lightDir, normal) == 0), то точка затенена. Если dot(lightDir, normal) > 0, то это - обратная сторона объекта, она также считается затенённой.

После того, как мы определили освещённость color, как float число 0..1, мы можем составить палитру символов, расположенных в порядке увеличения яркости. Я использовал такую: char palette[] = " .-,/+=ohPb8#"
и вывести её соответствующий элемент: printf("%c", palette[(int)(strlen(palette) * color)])

Ну вот, собственно, и всё, пф! Делов-то. Разумеется, я не питаю надежд, что внезапно всё станет понятно, поэтому жду от вас, дорогие слушатели, вопросов! И, если повезёт, каких-то промежуточных результатов.